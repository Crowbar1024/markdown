# 位运算
## 基本定义
- 原码：最高位是符号。不用的理由：两个正数相减，第二个变负数再相加，其符号位取1，相加后和的符号位还是1，显然是错的。8位范围[-127,127]
- 反码：负数的反码是符号位不变，剩下取反。所以0有两种表示，符号位是0/1的两种情况。8位范围[-127,127]
- 补码：负数的补码是其反码+1（-x == ~x + 1，x > 0）。这样负数可以表示更高的值，比如8位可以表示最小的数为-128，即原来反码-0，然而，这样的结果是最小的数没有8位所对应的原码和反码，所以对这个最小值的操作要小心。8位范围[-128,127]。意义就在于加法时不用判断正负。



## 进阶
http://graphics.stanford.edu/~seander/bithacks.html
https://xr1s.me/2022/10/20/gcc-builtin-implementations/

## 基本操作
**左右儿子都不存在返回true，一个存在一个不存在返回false，不处理都存在的情况**
```cpp
if (!l || !r) return l == r;
```

### 异或^
* a-b间不断变化，或者2选1
```cpp
if(x==a) x=b;
else x=a; 
x ^= a^b;
x ^= 1 // 0-1间不断变化
```
* swap
```cpp
a ^= b;
b ^= a;
a ^= b;
```
* dfs中数据恢复，x = 1; dfs(); x = 0;

* 判断同号，避免溢出
```cpp
(a^b) > 0 // 同号为正，异号为负
```

### 与运算&
* 判断奇偶
```cpp
x & 1
```

* 获得x的二进制最后一个1所对应的数
```cpp
digit = x & (-x) // 等价于 x & (~x+1)，利用负数补码的性质
```
* 删除x的二进制最后一个1所对应的数
```cpp
x &= x-1
```
* 判断x是否是2的幂
```cpp
(x & (x - 1)) == 0
```

* 判断x是否是4的幂（32位）
```cpp
// 4          0100 
// 16    0001 0000
// 64    0100 0000
// 规律：1只出现在除1之外的奇数位上
x != 1 && (x & 0x5555) == 1 // 0x5 = 0101，删掉偶数位上的1
```

* 向上取整RoundUp
```cpp
// __ALIGN一般取8，相当于 (bytes+7) 向上取整
static size_t ROUND_UP(size_t bytes) {
  return (((bytes) + __ALIGN-1) & ~(__ALIGN - 1));
}
```

### 移位>> <<
* 二叉树的左右儿子
```cpp
l = i<<1|1 // 下标从0开始
```

* x的第m位的相关操作（下标从0开始）
```cpp
(1 << (m-1)) | x  // 第m位的数置为1
(~(1 << (m-1))) & x  // 第m位的数置为0
```

* rotate 注意x是uint32_t
```cpp
(x >> 17) | (x << 15);  // Rotate right 17 bits
```



## 进阶
**求子集和补集**

在状态压缩DP中得到应用
```cpp
// n个任务，0表示选取，1表示不选，所以一共有2^n种状态
vector<int> dp(m); // m=1<<n [000:111]

// 如果选了第1个，第3个，第4个，即0000 1101，为状态i
// {1,3,4}的子集为
// 1101 & 1100 = 1100 3 4
// 1101 & 1011 = 1001 1 4
// 1101 & 1000 = 1000 4
// 1101 & 0111 = 0101 1 3
// 1101 & 0100 = 0100 3
// 1101 & 0011 = 0001 1
// 1101 & 0000 = 0
// 可以发现，其实可以不用遍历到0，根据最高位是否为1，可以将子集分为两半
// 3,4-1，1,4-3，4-1,3，即对应的部分为{1,3,4}的补集
// 如果j为i的子集，那么i^j为j对应i的补集
// 1100^1101 = 1(1) 1001^1101=0100(3)
int pivot = i>>1;
for (int j = i; j > ; j = i&(j-1)) {
    dp[i] = min(dp[i], dp[j]+dp[i^j])
}


```







**需要无穷大+无穷大不会溢出**
```cpp
0x3f3f3f3f
memset(a,0x3f,sizeof(a));  // 让数组每个元素都是无穷大
```



### popcount问题
https://blog.csdn.net/weixin_30587927/article/details/101093369
核心思想：相加完毕后，现在每2位是一组，每一组保存的都是最初在这2位的1的个数
相加完毕后，现在每4位是一组，并且每组保存的都是最初这4位的1的个数
```cpp
int BitCount(unsigned int n) { 
    n = (n & 0x55555555) + ((n >>1) &0x55555555); // 01
    n = (n & 0x33333333) + ((n >>2) &0x33333333); // 0011
    n = (n & 0x0f0f0f0f) + ((n >>4) &0x0f0f0f0f); // 00001111
    n = (n & 0x00ff00ff) + ((n >>8) &0x00ff00ff); // 00ff
    n = (n & 0x0000ffff) + ((n >>16) &0x0000ffff); 
    return n ; 
}

```

除了位运算之外，用空间换时间
```cpp
int lookup_popcnt(uint32_t n) {
#if 0  // generate the table algorithmically, and you should put it outside.
    static uint8_t table[256] = {0};
    for(uint32_t i = 1; i < 256; ++i)
        table[i] = table[i>>1] + i & 1U;
    
    const uint8_t* p = reinterpret_cast<const uint8_t*>(&n);
    return table[p[0]] + table[p[1]] + table[p[2]] + table[p[3]];
#else
# define BIT2(n)       n,       n+1,       n+1,       n+2
# define BIT4(n) BIT2(n), BIT2(n+1), BIT2(n+1), BIT2(n+2)
# define BIT6(n) BIT4(n), BIT4(n+1), BIT4(n+1), BIT4(n+2)
# define BIT8(n) BIT6(n), BIT6(n+1), BIT6(n+1), BIT6(n+2)

    static const uint8_t table[256] = {BIT8(0)};
    return table[n & 0xFF] + table[(n>>8) & 0xFF] +
           table[(n>>16) & 0xFF] + table[(n>>24) & 0xFF];
#endif          
}
// 32位的数数1，从return那里可以看出，就是每8位数一次，那么显然table[x]存的是[0,255]（2^8=256）
// 有1的个数。举个例子：table[0]=0 table[1]=1 table[2]=1 table[3]=2
// 可以发现规律为 table[x]=table[x>>1]+x&1
// 这个就可以写成宏递归的形式，很厉害，翻译一下
// [0,3]是[00,01,10,11]个数为{0,1,1,2}
// [4,7]是[100,101,110,111]个数为[0,3]+1
// [8,11]是[1000,1001,1010,1011]个数为[0,3]+1
// [12,15]是[1100,1101,1110,1111]个数为[0,3]+2
// 同理[16,31]是[0,15]+1
```




## 内置函数

```cpp
__builtin_ctz(x) // 尾0个数
__builtin_ffs(x) // 尾0个数+1，即从后往前第几位是1
__builtin_popcount(x) // 数1
```



### Ｃ++ 为什么要默认采用 < 来作为std::sort()和其他与排序相关的函数的比较符号呢?

因为<满足strict weak ordering，即能够表达其他所有的逻辑运算符：
| 逻辑运算符 | < |
| :-: | :-: |
| <= | !(b < a) |
| == | !(a < b) && !(b < a) |
| != | (a < b) \|\| (b < a) |
