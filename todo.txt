所以对于第三方库，我的原则是学习第一使用第二。比如说有一天我们要做一个实时排名的服务，得知redis能做到。
于是就去看redis的源码，知道其用的是一个叫做跳表的数据结构。
然后我们也用跳表，实现了一个200行左右的实时排名组件。
对于这样一个功能，比起直接采用几万行的redis，自己来实现肯定要更好。


排行榜的话，treap比跳表更简单啊，redis的跳表不够独立，参考起来还是很麻烦的


B-Tree 其实就是给 HDD 发明的。


关于用一个结构存储大量数据
这种情况是做一个生成器，itertools，pandas 之类的都是这么干的，然后每次操作是从生成器里取出下一个



单次dijkstra无法解决边权的问题，因为其和难以初始化

// 由于没有边的约束，只给了点的信息，即涉及到走来走去，bfs更好，并且可以在一个循环中得到一个联通图的节点数量

// 并且为了不建立visit，使用消元法，而消元的前提就是没有边

输入一个域名，处理这个请求的服务器组有多台服务器，通过哈希负载均衡，








问答
设计一个针对全球的，访问量极大的id生成系统，必须保证用户每次从该系统得到的ID是唯一的，而且在概率上毫无碰撞可能。
比如我要从成都服务器拿我的ID，成都服务器1s需要十万的ID，那么中国服务器可能一天前给了成都服务器一个startID和range。 成都服务器的ID库就是[startID,startID+range]，这个range给了保证。




只求一次组合不如DP



为了实现哈希集合这一数据结构，有以下几个关键问题需要解决：


哈希的冲突处理：由于不同元素可能映射到相同的整数值，因此需要在整数值出现「冲突」时，需要进行冲突处理。总的来说，有以下几种策略解决冲突：
链地址法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。
开放地址法：当发现哈希值某处产生冲突时，根据某种策略，从该处出发找到下一个不冲突的位置。例如，一种最简单的策略是，不断地检查下一个。
再哈希法：当发现哈希冲突后，使用另一个哈希函数产生一个新的地址。
扩容：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。


哈希函数质数取模，其实是利用了同余的概念：当元素是个有规律的等差数列时，并且和base不互质时，就会造成数组某些位置永远不会有值。

比如数列0,6,12,18,24,30...，base为10。

取模(0,6,2,8,4,0...)后，放入哈希表中位置将只能在0,2,4,6,8这几个数组位置上；
但我们如果把base取7（数组大小甚至比10小），同样数列取模后(0,6,5,4,3,2,1,0,...)，可以分布在哈希表中的0,1,2,3,4,5,6所有位置上；