背包问题也没什么特殊，就是初始化的不同。

组合数也是DP的一种，注意初始化

排列也可以用DP做，比如377，可以写成sum{dp}的形式

### 判断这是一个DP问题？
XX不重复/允许重复
出现和为XX，
要求XX个数最少
最短XX


### 初始化和dp[0]
一般情况下，初始化的是没有物品时，装满一定体积背包的重量，所以恰好装满不可能存在，设为负数。
而dp[0]指的是0装空背包，看题意设置。
同时需要注意，外循环从0开始说明遍历的是数组，下标为0
从1开始，一般不是和数组有关

### 初始化和状态压缩
拿最常见的二维数组举例，一般需要初始化 dp[0][j]和dp[i][0]，即第0行和第0列。假设return dp[m][n]，即行数m+1，列数n+1。

状态压缩后，保存的都是一行的数据，即需要创建 dp(n+1)。这样只能初始化第0行的信息，即初始化为dp[0][j]。这样就少了第0列的初始化。

那么在循环中，就需要加入这个步骤。即每次dp[i][0]的赋值，状态压缩后就是dp[0]。

如果在更新状态方程中存在左上角，即dp[i-1][j-1]。状压就用一个变量保存它。或者用翻转遍历顺序的方法节省。

这样每次遍历时的dp[j]为上一轮的dp[i-1][j]，那么就是下一次遍历的dp[i-1][j-1]。
对它的初始化比较绕，即上一行的第一列。

### 状态压缩和循环顺序
如果dp[i][j]和dp[i-1][j]、dp[i][j-1]和dp[i-1][j-1]有关，即上，左，左上有关，那么遍历顺序定死了。
只和dp[i-1][j-1]或dp[i-1][j]或dp[i][j-1]有关，没有定死，可以用翻转遍历顺序的方法节省一个prev变量。

### 下标0歧义
dp最好不要定义成下标i的XX



### 内外循环对象
如果求组合数就是外层for循环遍历物品，内层for遍历背包：518
如果求排列数就是外层for遍历背包，内层for循环遍历物品：377，70拓展，
求最小，最大，是否存在，无关顺序：279，322